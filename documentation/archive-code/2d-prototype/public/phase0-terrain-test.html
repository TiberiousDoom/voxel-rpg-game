<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phase 0: Terrain Height Prototype Test</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #fff;
    }

    h1 {
      margin: 0 0 10px 0;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .test-section {
      background: #2a2a2a;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    canvas {
      border: 2px solid #444;
      background: #000;
      display: block;
      margin: 10px 0;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0;
    }

    button {
      background: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
    }

    button:hover {
      background: #45a049;
    }

    button.test-button {
      background: #2196F3;
    }

    button.test-button:hover {
      background: #0b7dda;
    }

    .info {
      background: #333;
      padding: 10px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin: 10px 0;
    }

    .result {
      padding: 5px 10px;
      margin: 5px 0;
      border-radius: 4px;
    }

    .result.success {
      background: #2d5016;
      border-left: 4px solid #4CAF50;
    }

    .result.fail {
      background: #5c1a1a;
      border-left: 4px solid #f44336;
    }

    .legend {
      display: flex;
      gap: 15px;
      margin: 10px 0;
      font-size: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-color {
      width: 30px;
      height: 20px;
      border: 1px solid #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üóª Phase 0: Terrain Height Integration Prototype</h1>
    <p>Testing terrain height map integration with existing game systems before full implementation.</p>

    <!-- Terrain Visualization -->
    <div class="test-section">
      <h2>1. Terrain Height Visualization</h2>
      <p>10x10 test grid with varied terrain heights (0=flat, 10=peak)</p>
      <canvas id="terrainCanvas" width="400" height="400"></canvas>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: rgb(34, 139, 34);"></div>
          <span>Height 0 (Flat)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgb(84, 189, 44);"></div>
          <span>Height 5 (Medium)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgb(134, 219, 54);"></div>
          <span>Height 10 (Peak)</span>
        </div>
      </div>

      <div class="info" id="terrainInfo">
        Click to initialize terrain...
      </div>
    </div>

    <!-- Building Placement Tests -->
    <div class="test-section">
      <h2>2. Building Placement on Slopes</h2>
      <p>Testing if buildings can be placed on terrain with height variations.</p>

      <div class="controls">
        <button class="test-button" onclick="testFlatPlacement()">Test: Flat Area (0,0 2x2)</button>
        <button class="test-button" onclick="testSlopePlacement()">Test: Gentle Slope (5,2 2x2)</button>
        <button class="test-button" onclick="testSteepPlacement()">Test: Steep Hill (8,8 2x2)</button>
        <button class="test-button" onclick="testAutoFlatten()">Test: Auto-Flatten</button>
      </div>

      <div id="placementResults"></div>
    </div>

    <!-- Performance Baseline -->
    <div class="test-section">
      <h2>3. Performance Baseline</h2>
      <p>Measuring rendering performance with terrain enabled.</p>

      <div class="controls">
        <button class="test-button" onclick="measureFPS()">Measure FPS (1000 frames)</button>
      </div>

      <div class="info" id="performanceInfo">
        Click "Measure FPS" to benchmark...
      </div>
    </div>

    <!-- Integration Decisions -->
    <div class="test-section">
      <h2>4. Integration Decisions (To Document)</h2>
      <div class="info">
        <strong>Questions to Answer:</strong><br>
        1. Can buildings be placed on slopes? (Max slope tolerance: ?)<br>
        2. Should terrain auto-flatten under buildings?<br>
        3. What's the performance impact of terrain rendering?<br>
        4. How does height affect building elevation (visual only or gameplay?)<br>
        5. Should pathfinding consider height costs?<br>
      </div>
    </div>
  </div>

  <script type="module">
    // Simple inline terrain prototype for testing
    // (In real implementation, this would be imported from TerrainHeightPrototype.js)

    class TerrainHeightPrototype {
      constructor(width = 10, height = 10) {
        this.width = width;
        this.height = height;
        this.heightMap = [];
        this.generateTestHeightMap();
      }

      generateTestHeightMap() {
        for (let z = 0; z < this.height; z++) {
          this.heightMap[z] = [];
          for (let x = 0; x < this.width; x++) {
            let height;

            // Bottom-left quadrant: Flat (height 0)
            if (x < this.width / 2 && z < this.height / 2) {
              height = 0;
            }
            // Bottom-right: Gentle slope (height 0-3)
            else if (x >= this.width / 2 && z < this.height / 2) {
              height = Math.floor((x - this.width / 2) / 2);
            }
            // Top-left: Medium elevation (height 2-4)
            else if (x < this.width / 2 && z >= this.height / 2) {
              height = 2 + Math.floor((z - this.height / 2) / 3);
            }
            // Top-right: Hill (height 0-8)
            else {
              const dx = x - this.width / 2;
              const dz = z - this.height / 2;
              const distance = Math.sqrt(dx * dx + dz * dz);
              const maxDistance = Math.sqrt((this.width / 2) ** 2 + (this.height / 2) ** 2);
              height = Math.floor((distance / maxDistance) * 8);
            }

            this.heightMap[z][x] = Math.max(0, Math.min(10, height));
          }
        }
      }

      getHeight(x, z) {
        if (x < 0 || x >= this.width || z < 0 || z >= this.height) {
          return -1;
        }
        return this.heightMap[z][x];
      }

      isRegionFlat(startX, startZ, width, depth, maxSlopeTolerance = 0) {
        let minHeight = Infinity;
        let maxHeight = -Infinity;

        for (let z = startZ; z < startZ + depth; z++) {
          for (let x = startX; x < startX + width; x++) {
            const height = this.getHeight(x, z);
            if (height === -1) {
              return { flat: false, minHeight: -1, maxHeight: -1, heightDiff: Infinity, reason: 'Out of bounds' };
            }
            minHeight = Math.min(minHeight, height);
            maxHeight = Math.max(maxHeight, height);
          }
        }

        const heightDiff = maxHeight - minHeight;

        return {
          flat: heightDiff <= maxSlopeTolerance,
          minHeight,
          maxHeight,
          heightDiff,
          reason: heightDiff > maxSlopeTolerance ? `Height difference ${heightDiff} exceeds tolerance ${maxSlopeTolerance}` : undefined
        };
      }

      getRegionAverageHeight(startX, startZ, width, depth) {
        let totalHeight = 0;
        let count = 0;

        for (let z = startZ; z < startZ + depth; z++) {
          for (let x = startX; x < startX + width; x++) {
            const height = this.getHeight(x, z);
            if (height !== -1) {
              totalHeight += height;
              count++;
            }
          }
        }

        return count > 0 ? Math.round(totalHeight / count) : 0;
      }

      flattenRegion(startX, startZ, width, depth, targetHeight = null) {
        if (targetHeight === null) {
          targetHeight = this.getRegionAverageHeight(startX, startZ, width, depth);
        }

        let cellsChanged = 0;

        for (let z = startZ; z < startZ + depth; z++) {
          for (let x = startX; x < startX + width; x++) {
            if (x >= 0 && x < this.width && z >= 0 && z < this.height) {
              if (this.heightMap[z][x] !== targetHeight) {
                this.heightMap[z][x] = targetHeight;
                cellsChanged++;
              }
            }
          }
        }

        return {
          success: true,
          cellsChanged,
          flattenedTo: targetHeight
        };
      }
    }

    // Global terrain instance
    let terrain = null;

    // Initialize terrain and render
    function initTerrain() {
      terrain = new TerrainHeightPrototype(10, 10);
      renderTerrain();
      updateTerrainInfo();
    }

    function renderTerrain() {
      const canvas = document.getElementById('terrainCanvas');
      const ctx = canvas.getContext('2d');
      const tileSize = 40;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let z = 0; z < terrain.height; z++) {
        for (let x = 0; x < terrain.width; x++) {
          const height = terrain.getHeight(x, z);

          const screenX = x * tileSize;
          const screenY = z * tileSize;

          // Color based on height
          const heightRatio = height / 10;
          const r = Math.floor(34 + heightRatio * 100);
          const g = Math.floor(139 + heightRatio * 80);
          const b = Math.floor(34 + heightRatio * 20);

          ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
          ctx.fillRect(screenX, screenY, tileSize, tileSize);

          // Grid lines
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.strokeRect(screenX, screenY, tileSize, tileSize);

          // Height number
          ctx.fillStyle = height > 5 ? '#fff' : '#000';
          ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(height.toString(), screenX + tileSize / 2, screenY + tileSize / 2);
        }
      }
    }

    function updateTerrainInfo() {
      const info = document.getElementById('terrainInfo');
      info.innerHTML = `
        <strong>Terrain Initialized:</strong> ${terrain.width}x${terrain.height} grid<br>
        <strong>Height Range:</strong> 0-10<br>
        <strong>Bottom-Left:</strong> Flat area (height 0) for testing flat placement<br>
        <strong>Bottom-Right:</strong> Gentle slope (height 0-3)<br>
        <strong>Top-Left:</strong> Medium elevation (height 2-4)<br>
        <strong>Top-Right:</strong> Hill (height 0-8)
      `;
    }

    // Building placement tests
    function testFlatPlacement() {
      const result = terrain.isRegionFlat(0, 0, 2, 2, 0);
      displayResult('placementResults', 'Flat Area (0,0 2x2)', result.flat, `
        Height Range: ${result.minHeight}-${result.maxHeight} (diff: ${result.heightDiff})<br>
        ${result.flat ? '‚úÖ Can place building (perfectly flat)' : '‚ùå Cannot place building: ' + result.reason}
      `);
    }

    function testSlopePlacement() {
      const result = terrain.isRegionFlat(5, 2, 2, 2, 0);
      displayResult('placementResults', 'Gentle Slope (5,2 2x2)', result.flat, `
        Height Range: ${result.minHeight}-${result.maxHeight} (diff: ${result.heightDiff})<br>
        ${result.flat ? '‚úÖ Can place building' : '‚ùå Cannot place with tolerance 0: ' + result.reason}<br>
        <em>Test with tolerance 1: ${terrain.isRegionFlat(5, 2, 2, 2, 1).flat ? '‚úÖ OK' : '‚ùå Still too steep'}</em>
      `);
    }

    function testSteepPlacement() {
      const result = terrain.isRegionFlat(8, 8, 2, 2, 0);
      displayResult('placementResults', 'Steep Hill (8,8 2x2)', result.flat, `
        Height Range: ${result.minHeight}-${result.maxHeight} (diff: ${result.heightDiff})<br>
        ${result.flat ? '‚úÖ Can place building' : '‚ùå Cannot place: ' + result.reason}<br>
        <em>Max slope tolerance needed: ${result.heightDiff}</em>
      `);
    }

    function testAutoFlatten() {
      const avgHeight = terrain.getRegionAverageHeight(5, 2, 2, 2);
      const flattenResult = terrain.flattenRegion(5, 2, 2, 2);
      renderTerrain(); // Re-render to show flattened area

      displayResult('placementResults', 'Auto-Flatten (5,2 2x2)', true, `
        Flattened ${flattenResult.cellsChanged} cells to height ${flattenResult.flattenedTo}<br>
        ‚úÖ Area is now flat and ready for building placement
      `);
    }

    function displayResult(containerId, testName, success, details) {
      const container = document.getElementById(containerId);
      const div = document.createElement('div');
      div.className = `result ${success ? 'success' : 'fail'}`;
      div.innerHTML = `<strong>${testName}:</strong><br>${details}`;
      container.appendChild(div);

      // Keep only last 5 results
      while (container.children.length > 5) {
        container.removeChild(container.firstChild);
      }
    }

    // Performance measurement
    function measureFPS() {
      const perfInfo = document.getElementById('performanceInfo');
      perfInfo.innerHTML = 'Measuring FPS...';

      const canvas = document.getElementById('terrainCanvas');
      const ctx = canvas.getContext('2d');
      const frames = 1000;
      let frameCount = 0;
      const startTime = performance.now();

      function renderFrame() {
        // Clear and render terrain
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const tileSize = 40;
        for (let z = 0; z < terrain.height; z++) {
          for (let x = 0; x < terrain.width; x++) {
            const height = terrain.getHeight(x, z);
            const screenX = x * tileSize;
            const screenY = z * tileSize;

            const heightRatio = height / 10;
            const r = Math.floor(34 + heightRatio * 100);
            const g = Math.floor(139 + heightRatio * 80);
            const b = Math.floor(34 + heightRatio * 20);

            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.fillRect(screenX, screenY, tileSize, tileSize);
          }
        }

        frameCount++;

        if (frameCount < frames) {
          requestAnimationFrame(renderFrame);
        } else {
          const endTime = performance.now();
          const totalTime = endTime - startTime;
          const fps = (frames / totalTime) * 1000;

          perfInfo.innerHTML = `
            <strong>Performance Baseline (10x10 terrain):</strong><br>
            Frames: ${frames}<br>
            Total Time: ${totalTime.toFixed(2)}ms<br>
            Average FPS: ${fps.toFixed(2)}<br>
            Frame Time: ${(totalTime / frames).toFixed(2)}ms<br>
            <em>${fps >= 60 ? '‚úÖ Excellent performance' : fps >= 30 ? '‚ö†Ô∏è Acceptable performance' : '‚ùå Performance concern'}</em>
          `;
        }
      }

      requestAnimationFrame(renderFrame);
    }

    // Make functions global for onclick handlers
    window.testFlatPlacement = testFlatPlacement;
    window.testSlopePlacement = testSlopePlacement;
    window.testSteepPlacement = testSteepPlacement;
    window.testAutoFlatten = testAutoFlatten;
    window.measureFPS = measureFPS;

    // Initialize on load
    initTerrain();
  </script>
</body>
</html>
